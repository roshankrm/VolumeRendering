# Parallel Distributed Axis-aligned Volume Rendering using MPI    
  
  
  

**Introduction**

Volume rendering is a technique used to visualize scalar datasets in three dimensions. In this project, the goal is to implement a parallel volume rendering system using MPI. The data is distributed across multiple processes, and each process is responsible for rendering a subdomain of the volume. The result is obtained by compositing the partial images generated by all processes. The rendering is performed using ray casting, with early ray termination as an optimization.

  
    
    

**Problem Description**

The problem is to perform axis-aligned volume rendering on a 3D scalar dataset using MPI, where:
-	Decomposition is either 1D (along one axis) or 2D (along two axes).
-	The rendering involves casting rays through the grid points along the Z direction using front-to-back compositing.
-	Early Ray Termination is implemented to enhance performance, stopping rays that achieve full opacity (or reaches the threshold).    

The program outputs:  
-	A rendered image of the dataset.
-	The fraction of rays that terminate early.
-	The total time taken for rendering.    
  

**DataSet Used**

This project was run on a dataset of size 2000x2000x400 provided to me by my professor. This code for volume rendering can be used for running on any other dataset containing float32 values. The sample output attached was the output I got by performing volume rendering on my dataset.
  
  

**Methodology**  

1. Decomposition Strategy  
-	1D Decomposition: Data is divided along the X or Y axis, and each process handles one subdomain.
-	2D Decomposition: Data is divided across both X and Y axes. Each process handles a block of the XY domain with the constraint that the number of processes in the X direction is greater than in the Y direction.

2. Ray Casting Algorithm  
The ray casting algorithm casts rays through the 3D data along the Z axis. The following parameters control the rendering:  
-	Step Size: Determines the distance between two sample points along each ray.
-	Opacity Function: Governs how opacity is accumulated along each ray.
-	Color Function: Determines the color contribution of each sample point.

3. Early Ray Termination  
Early ray termination stops rays that have accumulated enough opacity to prevent further light transmission. This reduces the computation for fully opaque rays, improving performance.  
  



**Code Implementation**  


1. Reading the parameters:  
This implementation involves parallel volume rendering using ray casting. The inputs, such as the file name, number of processors, 1D/2D partition type, step size, and X and Y bounds, are provided through command-line arguments. The real dimensions of the data are directly inferred from the file name.

2. Opacity and Colour dictionaries:  
The transfer functions for color and opacity are provided in separate files. Accessing these files repeatedly to retrieve interpolated values would be time-consuming and cause performance overhead. To optimize this, each process creates two dictionaries: op_dictionary for opacity values and color_dictionary for color values. These dictionaries store the key-value pairs from the transfer functions, and are generated locally by each process using the opacity_function and color_function.

3. Reading the file:  
After process 0 receives the command-line arguments, it invokes the read_data function. This function takes the file name as input, converts the data into x, y, z coordinates, and selects the subset of data that falls within the specified X and Y bounds. The relevant data is sent back to process 0 for further partitioning.

4. Data partitioning:  
A key task in the code is to partition the data across different processes based on the user-specified partition type (1D or 2D). Depending on the partition type, process 0 calls the divide_data_1D or divide_data_2D functions in a loop over the number of processes, distributing the appropriate portions of data to each process.
The divide_data_1D function partitions the data horizontally based on the process rank and the total number of processors. Similarly, the divide_data_2D function finds no of rows and columns by calling the function then divides the data both horizontally and vertically according to the rank and number of processes, then sends the extracted data back to process 0.

5. Finding Best split:  
In 2D portioning it always not possible to partition data with equal rows and columns. In that case it give more no of rows than columns. For example as 15 is not perfect square it returns no of rows as 5 and columns as 3.


6. Processing at each process:  
Once a process receives its assigned data, it starts performing ray casting along the z-axis. The generate_sub_image function is responsible for the ray casting and generation of the sub-image.



7. Ray casting:   
Ray casting is applied along the z-axis from front to back. Sampling begins at the first point along the z-axis, with samples collected at intervals determined by the step_size. Each sampled value is calculated using linear interpolation. The color and opacity for each point are then derived by interpolating with the precomputed values stored in the color_dictionary and op_dictionary.  
After calculating the color and opacity for each point, these values are used to update the final color and opacity at the corresponding (x, y) index of the sub_image and sub_opacity. If the opacity at any point becomes 1, ray casting is terminated early for that ray, and the count of early ray terminations is incremented.

8. Formula for Interpolation:  
Vp = (1 - alpha) * V1 + alpha * V2  
V1 is the original value just before the Vp  
V2 is the original value just after the Vp  
alpha is a/(a+b)   
Where  
a is difference between sample point and original point which is just before sample point   
b is difference between sample point and original point which is just after sample point  
This formula performs a weighted average between V1 and V2, where the weights are determined by the relative distances of the sample point from the two original points.  

9. Formula for front to back rendering:  
Ci’= Ci-1’ +(1-Ai-1’ ) CiAi  
Ai’= Ai-1’ +(1-Ai-1’ )Ai  
Where  
 A is opacity   
 C is color  
Ci-1’ , Ci’, Ci represents color of previous sample, next sample and current sample  
 Ai-1’ , Ai’, Ai represents opacity of previous sample, next sample and current sample  

10. Sub Image generation:  
Each process receives the sub_image, sub_opacity, and the count of early ray terminations from the generate_sub_image function. The process then generates an RGBA sub-image by combining the sub_image and sub_opacity arrays. The RGBA sub-image and the early ray termination count are then sent back to process 0.  

11. Final Image generation:  
Process 0 creates a 2D array to hold the final image. After receiving the RGBA sub-images from all other processes, it assembles them by placing each sub-image in its corresponding location within the final image array.   

12. Time calculation:  
Each process measures the time taken for the generate_sub_image function by recording the start time before calling the function and the end time after it returns. The time difference, representing the time spent in generating the sub-image, is calculated in seconds and sent to the rank 0 process. Rank 0 collects the time taken by each process, including its own, and determines the maximum time from all the processes. This maximum time represents the total computation time, as it reflects the slowest process in the parallel execution.  

13. Early ray terminations:  
 Each process sends the number of early ray terminations that occurred during the generation of its sub-image to rank 0. Rank 0 aggregates these values, including the early ray terminations from its own processing, to compute the total number of early ray terminations across all processes.  
  

  
    
**Instructions to run our code**  

Store the files "opacity_TF.txt" and "color_TF.txt" with the exact same name as specified here inside the directory where your executable file is.  

Use Command mpiexec to run our code. The command format would be like:  

`mpiexec -n 8 python3 vol.py Isabel_2000x2000x400_float32.raw 2 0.5 0 1999 0 1999`  

The command consists of the following:   
n val: where val specifies the number of processes to be used.  
python3 should be specified to run our python code. (Use python if python3 doesn't work)  
vol.py: name of the python file containing our code.  
Name of the input dataset.  
1 = 1D partitioning (along X or Y), 2 = 2D partitioning (along both X and Y)  
0.5 is the Integration step size during for ray casting algorithm   
X_bound_min  
X_bound_max  
Y_bound_min  
Y_bound_max   
  

After successful execution of program, the output will be saved as output_image.png








